Asked graph properties: length=10 ; width=8
                      : reading(200) writing(200) maths(300) fun(300) 
Lecture du fihier contenant la liste de modules:
modules.csvFichier correctement ouvert.
Verrification du contenu:
DrawNode: reading(0) writing(0) maths(80) fun(20) 
DotToDotMath: reading(0) writing(0) maths(70) fun(30) 
DotToDotWrite: reading(0) writing(70) maths(0) fun(30) 
Puzzle: reading(5) writing(0) maths(0) fun(95) 
ConnectsTheDots: reading(0) writing(0) maths(30) fun(70) 
CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
WritingWords: reading(0) writing(90) maths(0) fun(10) 
HoledText: reading(80) writing(10) maths(0) fun(10) 
CowTrainReading: reading(70) writing(0) maths(0) fun(30) 
Ordering: reading(0) writing(0) maths(75) fun(25) 
TimeReading: reading(0) writing(0) maths(95) fun(5) 
TextReading: reading(65) writing(0) maths(0) fun(35) 
TextUnderstanding: reading(95) writing(0) maths(0) fun(5) 
HiddenObjects: reading(5) writing(0) maths(20) fun(75) 
HoledWords: reading(65) writing(25) maths(0) fun(10) 
AlphabetSong: reading(20) writing(0) maths(0) fun(80) 
NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
WritingLetters: reading(0) writing(75) maths(0) fun(25) 

Base :
1*[Dot3] : DotToDotWrite: reading(0) writing(70) maths(0) fun(30) 
1*[Con5] : ConnectsTheDots: reading(0) writing(0) maths(30) fun(70) 
1*[Cow3] : CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
1*[Wri2] : WritingWords: reading(0) writing(90) maths(0) fun(10) 
1*[Hol9] : HoledText: reading(80) writing(10) maths(0) fun(10) 
1*[Tim1] : TimeReading: reading(0) writing(0) maths(95) fun(5) 
1*[Tex7] : TextUnderstanding: reading(95) writing(0) maths(0) fun(5) 
1*[Hol0] : HoledWords: reading(65) writing(25) maths(0) fun(10) 
1*[Num0] : NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
1*[Wri4] : WritingLetters: reading(0) writing(75) maths(0) fun(25) 
total: reading(255) writing(270) maths(270) fun(205) 
Hol0  remplace par  HiddenObjects: reading(5) writing(0) maths(20) fun(75) 
total: reading(195) writing(245) maths(290) fun(270) 
Dot3  remplace par  HiddenObjects: reading(5) writing(0) maths(20) fun(75) 
total: reading(200) writing(175) maths(310) fun(315) 
Wri4  remplace par  WritingWords: reading(0) writing(90) maths(0) fun(10) 
total: reading(200) writing(190) maths(310) fun(300) 

Set :
1*[Con5] : ConnectsTheDots: reading(0) writing(0) maths(30) fun(70) 
1*[Cow3] : CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
2*[Wri2] : WritingWords: reading(0) writing(90) maths(0) fun(10) 
1*[Hol9] : HoledText: reading(80) writing(10) maths(0) fun(10) 
1*[Tim1] : TimeReading: reading(0) writing(0) maths(95) fun(5) 
1*[Tex7] : TextUnderstanding: reading(95) writing(0) maths(0) fun(5) 
2*[Hid3] : HiddenObjects: reading(5) writing(0) maths(20) fun(75) 
1*[Num0] : NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 

-dep6--Con5--Cow3--Wri2--Wri2--Hol9--Tim1--Tex7--Hid3--Hid3--Num0--arr7-

Base :
1*[Dra8] : DrawNode: reading(0) writing(0) maths(80) fun(20) 
1*[Dot2] : DotToDotMath: reading(0) writing(0) maths(70) fun(30) 
1*[Dot3] : DotToDotWrite: reading(0) writing(70) maths(0) fun(30) 
1*[Puz6] : Puzzle: reading(5) writing(0) maths(0) fun(95) 
1*[Cow5] : CowTrainReading: reading(70) writing(0) maths(0) fun(30) 
1*[Ord8] : Ordering: reading(0) writing(0) maths(75) fun(25) 
1*[Tex1] : TextReading: reading(65) writing(0) maths(0) fun(35) 
1*[Hol0] : HoledWords: reading(65) writing(25) maths(0) fun(10) 
1*[Alp2] : AlphabetSong: reading(20) writing(0) maths(0) fun(80) 
1*[Wri4] : WritingLetters: reading(0) writing(75) maths(0) fun(25) 
total: reading(225) writing(170) maths(225) fun(380) 
Alp2  remplace par  NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
total: reading(220) writing(170) maths(300) fun(310) 
Cow5  remplace par  HoledWords: reading(65) writing(25) maths(0) fun(10) 
total: reading(215) writing(195) maths(300) fun(290) 
Num0  remplace par  Ordering: reading(0) writing(0) maths(75) fun(25) 
total: reading(200) writing(195) maths(300) fun(305) 

Set :
1*[Dra8] : DrawNode: reading(0) writing(0) maths(80) fun(20) 
1*[Dot2] : DotToDotMath: reading(0) writing(0) maths(70) fun(30) 
1*[Dot3] : DotToDotWrite: reading(0) writing(70) maths(0) fun(30) 
1*[Puz6] : Puzzle: reading(5) writing(0) maths(0) fun(95) 
2*[Ord8] : Ordering: reading(0) writing(0) maths(75) fun(25) 
1*[Tex1] : TextReading: reading(65) writing(0) maths(0) fun(35) 
2*[Hol0] : HoledWords: reading(65) writing(25) maths(0) fun(10) 
1*[Wri4] : WritingLetters: reading(0) writing(75) maths(0) fun(25) 
add->start
ModuleGE[dep6]->bestfork->start
ModuleGE[dep6]->bestfork>after find
Node[dep6]->bestfork->no match
ModuleGE[Con5]->bestfork->start
ModuleGE[Con5]->bestfork>after find
Node[Con5]->bestfork->no match
Node[Con5]->bestfork->new fork place
ModuleGE[Cow3]->bestfork->start
ModuleGE[Cow3]->bestfork>after find
Node[Cow3]->bestfork->no match
ModuleGE[Wri2]->bestfork->start
ModuleGE[Wri2]->bestfork>after find
Node[Wri2]->bestfork->no match
ModuleGE[Wri2]->bestfork->start
ModuleGE[Wri2]->bestfork>after find
Node[Wri2]->bestfork->no match
ModuleGE[Hol9]->bestfork->start
ModuleGE[Hol9]->bestfork>after find
Node[Hol9]->bestfork->no match
ModuleGE[Tim1]->bestfork->start
ModuleGE[Tim1]->bestfork>after find
Node[Tim1]->bestfork->no match
ModuleGE[Tex7]->bestfork->start
ModuleGE[Tex7]->bestfork>after find
Node[Tex7]->bestfork->no match
ModuleGE[Hid3]->bestfork->start
ModuleGE[Hid3]->bestfork>after find
Node[Hid3]->bestfork->no match
ModuleGE[Hid3]->bestfork->start
ModuleGE[Hid3]->bestfork>after find
Node[Hid3]->bestfork->no match
ModuleGE[Num0]->bestfork->start
ModuleGE[Num0]->bestfork>after find
Node[Num0]->bestfork->no match
ModuleGE[arr7]->bestfork->start
ModuleGE[arr7]->bestfork>after find
Node[arr7]->bestfork->no match
add->after bestFork
1*Dra8
1*Dot2
1*Dot3
1*Puz6
2*Ord8
1*Tex1
2*Hol0
1*Wri4
-Con5--Cow3--Wri2--Wri2--Hol9--Tim1--Tex7--Hid3--Hid3--Num0--arr7-
Node[Con5]->bestJunction->start
Node[Con5]->bestJunction->forward
Node[Con5]->bestJunction->module not found
Node[Cow3]->bestJunction->start
Node[Cow3]->bestJunction->forward
Node[Cow3]->bestJunction->module not found
Node[Wri2]->bestJunction->start
Node[Wri2]->bestJunction->forward
Node[Wri2]->bestJunction->module not found
Node[Wri2]->bestJunction->start
Node[Wri2]->bestJunction->forward
Node[Wri2]->bestJunction->module not found
Node[Hol9]->bestJunction->start
Node[Hol9]->bestJunction->forward
Node[Hol9]->bestJunction->module not found
Node[Tim1]->bestJunction->start
Node[Tim1]->bestJunction->forward
Node[Tim1]->bestJunction->module not found
Node[Tex7]->bestJunction->start
Node[Tex7]->bestJunction->forward
Node[Tex7]->bestJunction->module not found
Node[Hid3]->bestJunction->start
Node[Hid3]->bestJunction->forward
Node[Hid3]->bestJunction->module not found
Node[Hid3]->bestJunction->start
Node[Hid3]->bestJunction->forward
Node[Hid3]->bestJunction->module not found
Node[Num0]->bestJunction->start
Node[Num0]->bestJunction->forward
Node[Num0]->bestJunction->module not found
Node[arr7]->bestJunction->start
Node[arr7]->bestJunction->forward
Node[arr7]->bestJunction->module found or null
Node[arr7]->bestJunction->new junction place
Node[arr7]->bestJunction->recursive call
Node[arr7]->bestJunction->junctionPlace still on this path
Node[arr7]->bestJunction->exit
add->after BestJunction
-arr7-
add->path
add->Modules left:
1*Dra8
1*Dot2
1*Dot3
1*Puz6
2*Ord8
1*Tex1
2*Hol0
1*Wri4
add->forking right
add->forked first Node: Dra8
add->node Dot2
add->node Dot3
add->node Puz6
add->node Ord8
add->node Ord8
add->node Tex1
add->node Hol0
add->node Hol0
add->node Wri4
add->pathed
add->junction right
add->juncted
-dep6-<-Con5--Cow3--Wri2--Wri2--Hol9--Tim1--Tex7--Hid3--Hid3--Num0->-arr7-
      <-Dra8--Dot2--Dot3--Puz6--Ord8--Ord8--Tex1--Hol0--Hol0--Wri4->

Base :
1*[Dra8] : DrawNode: reading(0) writing(0) maths(80) fun(20) 
1*[Dot2] : DotToDotMath: reading(0) writing(0) maths(70) fun(30) 
1*[Puz6] : Puzzle: reading(5) writing(0) maths(0) fun(95) 
1*[Con5] : ConnectsTheDots: reading(0) writing(0) maths(30) fun(70) 
1*[Cow3] : CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
1*[Hol9] : HoledText: reading(80) writing(10) maths(0) fun(10) 
1*[Cow5] : CowTrainReading: reading(70) writing(0) maths(0) fun(30) 
1*[Tex1] : TextReading: reading(65) writing(0) maths(0) fun(35) 
1*[Tex7] : TextUnderstanding: reading(95) writing(0) maths(0) fun(5) 
1*[Hid3] : HiddenObjects: reading(5) writing(0) maths(20) fun(75) 
total: reading(320) writing(10) maths(270) fun(400) 
Puz6  remplace par  WritingWords: reading(0) writing(90) maths(0) fun(10) 
total: reading(315) writing(100) maths(270) fun(315) 
Tex7  remplace par  WritingWords: reading(0) writing(90) maths(0) fun(10) 
total: reading(220) writing(190) maths(270) fun(320) 
Cow5  remplace par  HoledWords: reading(65) writing(25) maths(0) fun(10) 
total: reading(215) writing(215) maths(270) fun(300) 
Wri2  remplace par  WritingLetters: reading(0) writing(75) maths(0) fun(25) 
total: reading(215) writing(200) maths(270) fun(315) 
Hid3  remplace par  ConnectsTheDots: reading(0) writing(0) maths(30) fun(70) 
total: reading(210) writing(200) maths(280) fun(310) 
Dra8  remplace par  TimeReading: reading(0) writing(0) maths(95) fun(5) 
total: reading(210) writing(200) maths(295) fun(295) 

Set :
1*[Dot2] : DotToDotMath: reading(0) writing(0) maths(70) fun(30) 
2*[Con5] : ConnectsTheDots: reading(0) writing(0) maths(30) fun(70) 
1*[Cow3] : CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
1*[Wri2] : WritingWords: reading(0) writing(90) maths(0) fun(10) 
1*[Hol9] : HoledText: reading(80) writing(10) maths(0) fun(10) 
1*[Tim1] : TimeReading: reading(0) writing(0) maths(95) fun(5) 
1*[Tex1] : TextReading: reading(65) writing(0) maths(0) fun(35) 
1*[Hol0] : HoledWords: reading(65) writing(25) maths(0) fun(10) 
1*[Wri4] : WritingLetters: reading(0) writing(75) maths(0) fun(25) 
add->start
ModuleGE[dep6]->bestfork->start
ModuleGE[dep6]->bestfork>after find
Node[dep6]->bestfork->no match
Fork->bestFork->start
Fork->bestFork->right recursive call
ModuleGE[Dra8]->bestfork->start
ModuleGE[Dra8]->bestfork>after find
Node[Dra8]->bestfork->no match
Node[Dra8]->bestfork->new fork place
ModuleGE[Dot2]->bestfork->start
ModuleGE[Dot2]->bestfork>after find
ModuleGE[Dot2]->bestfork->match
Node[Dot2]->bestfork->module erased
Node[Dot2]->bestfork->moving
Node[Dot2]->bestfork->recursive call and exit
ModuleGE[Dot3]->bestfork->start
ModuleGE[Dot3]->bestfork>after find
Node[Dot3]->bestfork->no match
ModuleGE[Puz6]->bestfork->start
ModuleGE[Puz6]->bestfork>after find
Node[Puz6]->bestfork->no match
ModuleGE[Ord8]->bestfork->start
ModuleGE[Ord8]->bestfork>after find
Node[Ord8]->bestfork->no match
ModuleGE[Ord8]->bestfork->start
ModuleGE[Ord8]->bestfork>after find
Node[Ord8]->bestfork->no match
ModuleGE[Tex1]->bestfork->start
ModuleGE[Tex1]->bestfork>after find
ModuleGE[Tex1]->bestfork->match
Node[Tex1]->bestfork->module erased
Node[Tex1]->bestfork->moving
Node[Tex1]->bestfork->recursive call and exit
ModuleGE[Hol0]->bestfork->start
ModuleGE[Hol0]->bestfork>after find
ModuleGE[Hol0]->bestfork->match
Node[Hol0]->bestfork->module erased
Node[Hol0]->bestfork->moving
Node[Hol0]->bestfork->recursive call and exit
ModuleGE[Hol0]->bestfork->start
ModuleGE[Hol0]->bestfork>after find
Node[Hol0]->bestfork->no match
ModuleGE[Wri4]->bestfork->start
ModuleGE[Wri4]->bestfork>after find
ModuleGE[Wri4]->bestfork->match
Node[Wri4]->bestfork->module erased
Node[Wri4]->bestfork->moving
Node[Wri4]->bestfork->recursive call and exit
Junction->bestFork
Fork->bestFork->left recursive call
ModuleGE[Con5]->bestfork->start
ModuleGE[Con5]->bestfork>after find
ModuleGE[Con5]->bestfork->match
Node[Con5]->bestfork->module erased
Node[Con5]->bestfork->recursive call and exit
ModuleGE[Cow3]->bestfork->start
ModuleGE[Cow3]->bestfork>after find
ModuleGE[Cow3]->bestfork->match
Node[Cow3]->bestfork->module erased
Node[Cow3]->bestfork->recursive call and exit
ModuleGE[Wri2]->bestfork->start
ModuleGE[Wri2]->bestfork>after find
ModuleGE[Wri2]->bestfork->match
Node[Wri2]->bestfork->module erased
Node[Wri2]->bestfork->recursive call and exit
ModuleGE[Wri2]->bestfork->start
ModuleGE[Wri2]->bestfork>after find
Node[Wri2]->bestfork->no match
Node[Wri2]->bestfork->new fork place
ModuleGE[Hol9]->bestfork->start
ModuleGE[Hol9]->bestfork>after find
ModuleGE[Hol9]->bestfork->match
Node[Hol9]->bestfork->module erased
Node[Hol9]->bestfork->moving
Node[Hol9]->bestfork->recursive call and exit
ModuleGE[Tim1]->bestfork->start
ModuleGE[Tim1]->bestfork>after find
ModuleGE[Tim1]->bestfork->match
Node[Tim1]->bestfork->module erased
Node[Tim1]->bestfork->moving
Node[Tim1]->bestfork->recursive call and exit
ModuleGE[Tex7]->bestfork->start
ModuleGE[Tex7]->bestfork>after find
Node[Tex7]->bestfork->no match
ModuleGE[Hid3]->bestfork->start
ModuleGE[Hid3]->bestfork>after find
Node[Hid3]->bestfork->no match
ModuleGE[Hid3]->bestfork->start
ModuleGE[Hid3]->bestfork>after find
Node[Hid3]->bestfork->no match
ModuleGE[Num0]->bestfork->start
ModuleGE[Num0]->bestfork>after find
Node[Num0]->bestfork->no match
Junction->bestFork
Fork->bestFork->back from recursive calls
Fork->bestFork->left>=right, delete and exit
add->after bestFork
1*Dot2
1*Con5
1*Tex1
1*Hol0
1*Wri4
-Wri2--Tex7--Hid3--Hid3--Num0->-arr7-
Node[Wri2]->bestJunction->start
Node[Wri2]->bestJunction->forward
Node[Wri2]->bestJunction->module not found
Node[Tex7]->bestJunction->start
Node[Tex7]->bestJunction->forward
Node[Tex7]->bestJunction->module not found
Node[Hid3]->bestJunction->start
Node[Hid3]->bestJunction->forward
Node[Hid3]->bestJunction->module not found
Node[Hid3]->bestJunction->start
Node[Hid3]->bestJunction->forward
Node[Hid3]->bestJunction->module not found
Node[Num0]->bestJunction->start
Node[Num0]->bestJunction->forward
Node[Num0]->bestJunction->module not found
Junction->bestJunction
Junction->bestJunction->moving forward
Junction->bestJunction->contains() call
Junction->bestJunction->contains() returned true (good result)
Junction->bestJunction->new junction place
Junction->bestJunction->side != calling side => back recursive call
Junction->bestJunction->right recursive call
Node[Hol0]->bestJunction->start
Node[Hol0]->bestJunction->backward
Node[Hol0]->bestJunction->module found, removing module
Node[Hol0]->moving node
Node[Hol0]->bestJunction->recursive call
Node[Ord8]->bestJunction->start
Node[Ord8]->bestJunction->backward
Node[Ord8]->bestJunction->module not found, recursive call
Node[Ord8]->bestJunction->start
Node[Ord8]->bestJunction->backward
Node[Ord8]->bestJunction->module not found, recursive call
Node[Puz6]->bestJunction->start
Node[Puz6]->bestJunction->backward
Node[Puz6]->bestJunction->module not found, recursive call
Node[Dot3]->bestJunction->start
Node[Dot3]->bestJunction->backward
Node[Dot3]->bestJunction->module not found, recursive call
Node[Dra8]->bestJunction->start
Node[Dra8]->bestJunction->backward
Node[Dra8]->bestJunction->module not found, recursive call
Node[Wri4]->bestJunction->start
Node[Wri4]->bestJunction->backward
Node[Wri4]->bestJunction->module found, removing module
Node[Wri4]->moving node
Node[Wri4]->bestJunction->recursive call
Node[Hol0]->bestJunction->start
Node[Hol0]->bestJunction->backward
Node[Hol0]->bestJunction->module not found, recursive call
Node[Tex1]->bestJunction->start
Node[Tex1]->bestJunction->backward
Node[Tex1]->bestJunction->module found, removing module
Node[Tex1]->moving node
Node[Tex1]->bestJunction->recursive call
Node[Dot2]->bestJunction->start
Node[Dot2]->bestJunction->backward
Node[Dot2]->bestJunction->module found, removing module
Node[Dot2]->moving node
Node[Dot2]->bestJunction->recursive call
Fork->bestJunction->start
Fork->bestJunction->moving backward
Fork->bestJunction->exit
Node[Dot2]->bestJunction->exit
Node[Tex1]->bestJunction->exit
Node[Hol0]->bestJunction->exit
Node[Wri4]->bestJunction->exit
Node[Dra8]->bestJunction->exit
Node[Dot3]->bestJunction->exit
Node[Puz6]->bestJunction->exit
Node[Ord8]->bestJunction->exit
Node[Ord8]->bestJunction->exit
Node[Hol0]->bestJunction->exit
Junction->bestJunction->back from back recursive call
Junction->bestJunction->new junction chosen
add->after BestJunction
-Dot2--Tex1--Wri4--Hol0->
add->path
add->Modules left:
1*Con5
add->forking right
add->forked first Node: Con5
add->pathed
add->junction left
add->juncted
-dep6-<-Con5--Cow3--Wri2--Hol9--Tim1-<-Wri2--Tex7--Hid3--Hid3--Num0->-arr7-
                                     <-Con5->-Dot2--Tex1--Wri4--Hol0->
      <-Hol0--Dra8--Dot3--Puz6--Ord8--Ord8->

Base :
1*[Dra8] : DrawNode: reading(0) writing(0) maths(80) fun(20) 
1*[Dot3] : DotToDotWrite: reading(0) writing(70) maths(0) fun(30) 
1*[Puz6] : Puzzle: reading(5) writing(0) maths(0) fun(95) 
1*[Cow5] : CowTrainReading: reading(70) writing(0) maths(0) fun(30) 
1*[Ord8] : Ordering: reading(0) writing(0) maths(75) fun(25) 
1*[Tim1] : TimeReading: reading(0) writing(0) maths(95) fun(5) 
1*[Tex7] : TextUnderstanding: reading(95) writing(0) maths(0) fun(5) 
1*[Hid3] : HiddenObjects: reading(5) writing(0) maths(20) fun(75) 
1*[Alp2] : AlphabetSong: reading(20) writing(0) maths(0) fun(80) 
1*[Num0] : NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
total: reading(210) writing(70) maths(345) fun(375) 
Hid3  remplace par  WritingWords: reading(0) writing(90) maths(0) fun(10) 
total: reading(205) writing(160) maths(325) fun(310) 
Cow5  remplace par  HoledWords: reading(65) writing(25) maths(0) fun(10) 
total: reading(200) writing(185) maths(325) fun(290) 
Dra8  remplace par  CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
total: reading(200) writing(185) maths(315) fun(300) 

Set :
1*[Dot3] : DotToDotWrite: reading(0) writing(70) maths(0) fun(30) 
1*[Puz6] : Puzzle: reading(5) writing(0) maths(0) fun(95) 
1*[Cow3] : CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
1*[Wri2] : WritingWords: reading(0) writing(90) maths(0) fun(10) 
1*[Ord8] : Ordering: reading(0) writing(0) maths(75) fun(25) 
1*[Tim1] : TimeReading: reading(0) writing(0) maths(95) fun(5) 
1*[Tex7] : TextUnderstanding: reading(95) writing(0) maths(0) fun(5) 
1*[Hol0] : HoledWords: reading(65) writing(25) maths(0) fun(10) 
1*[Alp2] : AlphabetSong: reading(20) writing(0) maths(0) fun(80) 
1*[Num0] : NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
add->start
ModuleGE[dep6]->bestfork->start
ModuleGE[dep6]->bestfork>after find
Node[dep6]->bestfork->no match
Fork->bestFork->start
Fork->bestFork->right recursive call
ModuleGE[Hol0]->bestfork->start
ModuleGE[Hol0]->bestfork>after find
ModuleGE[Hol0]->bestfork->match
Node[Hol0]->bestfork->module erased
Node[Hol0]->bestfork->recursive call and exit
ModuleGE[Dra8]->bestfork->start
ModuleGE[Dra8]->bestfork>after find
Node[Dra8]->bestfork->no match
Node[Dra8]->bestfork->new fork place
ModuleGE[Dot3]->bestfork->start
ModuleGE[Dot3]->bestfork>after find
ModuleGE[Dot3]->bestfork->match
Node[Dot3]->bestfork->module erased
Node[Dot3]->bestfork->moving
Node[Dot3]->bestfork->recursive call and exit
ModuleGE[Puz6]->bestfork->start
ModuleGE[Puz6]->bestfork>after find
ModuleGE[Puz6]->bestfork->match
Node[Puz6]->bestfork->module erased
Node[Puz6]->bestfork->moving
Node[Puz6]->bestfork->recursive call and exit
ModuleGE[Ord8]->bestfork->start
ModuleGE[Ord8]->bestfork>after find
ModuleGE[Ord8]->bestfork->match
Node[Ord8]->bestfork->module erased
Node[Ord8]->bestfork->moving
Node[Ord8]->bestfork->recursive call and exit
ModuleGE[Ord8]->bestfork->start
ModuleGE[Ord8]->bestfork>after find
Node[Ord8]->bestfork->no match
Junction->bestFork
Fork->bestFork->left recursive call
ModuleGE[Con5]->bestfork->start
ModuleGE[Con5]->bestfork>after find
Node[Con5]->bestfork->no match
Node[Con5]->bestfork->new fork place
ModuleGE[Cow3]->bestfork->start
ModuleGE[Cow3]->bestfork>after find
ModuleGE[Cow3]->bestfork->match
Node[Cow3]->bestfork->module erased
Node[Cow3]->bestfork->moving
Node[Cow3]->bestfork->recursive call and exit
ModuleGE[Wri2]->bestfork->start
ModuleGE[Wri2]->bestfork>after find
ModuleGE[Wri2]->bestfork->match
Node[Wri2]->bestfork->module erased
Node[Wri2]->bestfork->moving
Node[Wri2]->bestfork->recursive call and exit
ModuleGE[Hol9]->bestfork->start
ModuleGE[Hol9]->bestfork>after find
Node[Hol9]->bestfork->no match
ModuleGE[Tim1]->bestfork->start
ModuleGE[Tim1]->bestfork>after find
ModuleGE[Tim1]->bestfork->match
Node[Tim1]->bestfork->module erased
Node[Tim1]->bestfork->moving
Node[Tim1]->bestfork->recursive call and exit
Fork->bestFork->start
Fork->bestFork->fork place already found, exit
Fork->bestFork->back from recursive calls
Fork->bestFork->left<right, delete and exit
add->after bestFork
1*Cow3
1*Wri2
1*Tim1
1*Tex7
1*Alp2
1*Num0
-Dra8--Ord8->
Node[Dra8]->bestJunction->start
Node[Dra8]->bestJunction->forward
Node[Dra8]->bestJunction->module not found
Node[Ord8]->bestJunction->start
Node[Ord8]->bestJunction->forward
Node[Ord8]->bestJunction->module not found
Junction->bestJunction
Junction->bestJunction->moving forward
Junction->bestJunction->contains() call
Junction->bestJunction->contains() returned false=> junction place is bad
Junction->bestJunction->compatible side => forward recursive call
Node[Dot2]->bestJunction->start
Node[Dot2]->bestJunction->forward
Node[Dot2]->bestJunction->module not found
Node[Tex1]->bestJunction->start
Node[Tex1]->bestJunction->forward
Node[Tex1]->bestJunction->module not found
Node[Wri4]->bestJunction->start
Node[Wri4]->bestJunction->forward
Node[Wri4]->bestJunction->module not found
Node[Hol0]->bestJunction->start
Node[Hol0]->bestJunction->forward
Node[Hol0]->bestJunction->module not found
Junction->bestJunction
Junction->bestJunction->moving forward
Junction->bestJunction->contains() call
Junction->bestJunction->contains() returned true (good result)
Junction->bestJunction->new junction place
Junction->bestJunction->exit
Junction->bestJunction->back from recursive call, exit
add->after BestJunction
>
add->path
add->Modules left:
1*Cow3
1*Wri2
1*Tim1
1*Tex7
1*Alp2
1*Num0
add->forking right
add->forked first Node: Cow3
add->node Wri2
add->node Tim1
add->node Tex7
add->node Alp2
add->node Num0
add->pathed
add->junction right
add->juncted
-dep6-<-Cow3--Wri2--Tim1--Con5--Hol9-<-Wri2--Tex7--Hid3--Hid3--Num0->-arr7-
                                     <-Con5->-Dot2--Tex1--Wri4--Hol0->>
      <-Hol0--Dot3--Puz6--Ord8-<-Dra8--Ord8->
                               <-Cow3--Wri2--Tim1--Tex7--Alp2--Num0->

Base :
1*[Dra8] : DrawNode: reading(0) writing(0) maths(80) fun(20) 
1*[Con5] : ConnectsTheDots: reading(0) writing(0) maths(30) fun(70) 
1*[Ord8] : Ordering: reading(0) writing(0) maths(75) fun(25) 
1*[Tim1] : TimeReading: reading(0) writing(0) maths(95) fun(5) 
1*[Tex1] : TextReading: reading(65) writing(0) maths(0) fun(35) 
1*[Tex7] : TextUnderstanding: reading(95) writing(0) maths(0) fun(5) 
1*[Hid3] : HiddenObjects: reading(5) writing(0) maths(20) fun(75) 
1*[Alp2] : AlphabetSong: reading(20) writing(0) maths(0) fun(80) 
1*[Num0] : NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
1*[Wri4] : WritingLetters: reading(0) writing(75) maths(0) fun(25) 
total: reading(200) writing(75) maths(375) fun(350) 
Ord8  remplace par  WritingWords: reading(0) writing(90) maths(0) fun(10) 
total: reading(200) writing(165) maths(300) fun(335) 
Tex1  remplace par  HoledWords: reading(65) writing(25) maths(0) fun(10) 
total: reading(200) writing(190) maths(300) fun(310) 

Set :
1*[Dra8] : DrawNode: reading(0) writing(0) maths(80) fun(20) 
1*[Con5] : ConnectsTheDots: reading(0) writing(0) maths(30) fun(70) 
1*[Wri2] : WritingWords: reading(0) writing(90) maths(0) fun(10) 
1*[Tim1] : TimeReading: reading(0) writing(0) maths(95) fun(5) 
1*[Tex7] : TextUnderstanding: reading(95) writing(0) maths(0) fun(5) 
1*[Hid3] : HiddenObjects: reading(5) writing(0) maths(20) fun(75) 
1*[Hol0] : HoledWords: reading(65) writing(25) maths(0) fun(10) 
1*[Alp2] : AlphabetSong: reading(20) writing(0) maths(0) fun(80) 
1*[Num0] : NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
1*[Wri4] : WritingLetters: reading(0) writing(75) maths(0) fun(25) 
add->start
ModuleGE[dep6]->bestfork->start
ModuleGE[dep6]->bestfork>after find
Node[dep6]->bestfork->no match
Fork->bestFork->start
Fork->bestFork->right recursive call
ModuleGE[Hol0]->bestfork->start
ModuleGE[Hol0]->bestfork>after find
ModuleGE[Hol0]->bestfork->match
Node[Hol0]->bestfork->module erased
Node[Hol0]->bestfork->recursive call and exit
ModuleGE[Dot3]->bestfork->start
ModuleGE[Dot3]->bestfork>after find
Node[Dot3]->bestfork->no match
Node[Dot3]->bestfork->new fork place
ModuleGE[Puz6]->bestfork->start
ModuleGE[Puz6]->bestfork>after find
Node[Puz6]->bestfork->no match
ModuleGE[Ord8]->bestfork->start
ModuleGE[Ord8]->bestfork>after find
Node[Ord8]->bestfork->no match
Fork->bestFork->start
Fork->bestFork->fork place already found, exit
Fork->bestFork->left recursive call
ModuleGE[Cow3]->bestfork->start
ModuleGE[Cow3]->bestfork>after find
Node[Cow3]->bestfork->no match
Node[Cow3]->bestfork->new fork place
ModuleGE[Wri2]->bestfork->start
ModuleGE[Wri2]->bestfork>after find
ModuleGE[Wri2]->bestfork->match
Node[Wri2]->bestfork->module erased
Node[Wri2]->bestfork->moving
Node[Wri2]->bestfork->recursive call and exit
ModuleGE[Tim1]->bestfork->start
ModuleGE[Tim1]->bestfork>after find
ModuleGE[Tim1]->bestfork->match
Node[Tim1]->bestfork->module erased
Node[Tim1]->bestfork->moving
Node[Tim1]->bestfork->recursive call and exit
ModuleGE[Con5]->bestfork->start
ModuleGE[Con5]->bestfork>after find
ModuleGE[Con5]->bestfork->match
Node[Con5]->bestfork->module erased
Node[Con5]->bestfork->moving
Node[Con5]->bestfork->recursive call and exit
ModuleGE[Hol9]->bestfork->start
ModuleGE[Hol9]->bestfork>after find
Node[Hol9]->bestfork->no match
Fork->bestFork->start
Fork->bestFork->fork place already found, exit
Fork->bestFork->back from recursive calls
Fork->bestFork->left>=right, delete and exit
add->after bestFork
1*Dra8
1*Tex7
1*Hid3
1*Hol0
1*Alp2
1*Num0
1*Wri4
-Cow3--Hol9-<-Wri2--Tex7--Hid3--Hid3--Num0->-arr7-
            <-Con5->-Dot2--Tex1--Wri4--Hol0->>
Node[Cow3]->bestJunction->start
Node[Cow3]->bestJunction->forward
Node[Cow3]->bestJunction->module not found
Node[Hol9]->bestJunction->start
Node[Hol9]->bestJunction->forward
Node[Hol9]->bestJunction->module not found
Fork->bestJunction->start
Fork->bestJunction->moving forward
Fork->bestJunction->side = both
Fork->bestJunction->left recursive call
Node[Wri2]->bestJunction->start
Node[Wri2]->bestJunction->forward
Node[Wri2]->bestJunction->module not found
Node[Tex7]->bestJunction->start
Node[Tex7]->bestJunction->forward
Node[Tex7]->bestJunction->module found or null
Node[Tex7]->bestJunction->removing module
Node[Tex7]->bestJunction->new junction place
Node[Tex7]->bestJunction->recursive call
Node[Hid3]->bestJunction->start
Node[Hid3]->bestJunction->forward
Node[Hid3]->bestJunction->module found or null
Node[Hid3]->bestJunction->removing module
Node[Hid3]->bestJunction->recursive call
Node[Hid3]->bestJunction->start
Node[Hid3]->bestJunction->forward
Node[Hid3]->bestJunction->module not found
Node[0x996708]->bestJunction->moving node
Node[0x996708]->bestJunction->recursive call and exit
Node[Num0]->bestJunction->start
Node[Num0]->bestJunction->forward
Node[Num0]->bestJunction->module found or null
Node[Num0]->bestJunction->removing module
Node[Num0]->bestJunction->recursive call
Junction->bestJunction
Junction->bestJunction->moving forward
Junction->bestJunction->contains() call
Junction->bestJunction->contains() returned true (good result)
Junction->bestJunction->exit
Node[Num0]->bestJunction->junctionPlace still on this path
Node[Num0]->bestJunction->exit
Node[Hid3]->bestJunction->junctionPlace still on this path
Node[Hid3]->bestJunction->exit
Node[Tex7]->bestJunction->junctionPlace still on this path
Node[Tex7]->bestJunction->exit
Fork->bestJunction->right recursive call
Node[Con5]->bestJunction->start
Node[Con5]->bestJunction->forward
Node[Con5]->bestJunction->module not found
Junction->bestJunction
Junction->bestJunction->moving forward
Junction->bestJunction->contains() call
Junction->bestJunction->contains() returned false=> junction place is bad
Junction->bestJunction->not compatible side
Junction->bestJunction->exit
Fork->bestJunction->back from recursive calls
Fork->bestJunction->choosing left
Fork->bestJunction->exit
add->after BestJunction
-Tex7--Hid3--Num0->-arr7-
add->path
add->Modules left:
1*Dra8
1*Hol0
1*Alp2
1*Wri4
add->forking left
add->forked first Node: Dra8
add->node Hol0
add->node Alp2
add->node Wri4
add->pathed
add->junction left
add->juncted
-dep6-<-Wri2--Tim1--Con5-<-Dra8--Hol0--Alp2--Wri4->-Tex7--Hid3--Num0->-arr7-
                         <-Cow3--Hol9-<-Wri2--Hid3->
                                      <-Con5->-Dot2--Tex1--Wri4--Hol0->>
      <-Hol0--Dot3--Puz6--Ord8-<-Dra8--Ord8->
                               <-Cow3--Wri2--Tim1--Tex7--Alp2--Num0->

Base :
1*[Dot3] : DotToDotWrite: reading(0) writing(70) maths(0) fun(30) 
1*[Puz6] : Puzzle: reading(5) writing(0) maths(0) fun(95) 
1*[Cow3] : CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
1*[Wri2] : WritingWords: reading(0) writing(90) maths(0) fun(10) 
2*[Cow5] : CowTrainReading: reading(70) writing(0) maths(0) fun(30) 
1*[Ord8] : Ordering: reading(0) writing(0) maths(75) fun(25) 
1*[Tex1] : TextReading: reading(65) writing(0) maths(0) fun(35) 
1*[Alp2] : AlphabetSong: reading(20) writing(0) maths(0) fun(80) 
1*[Num0] : NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
total: reading(245) writing(160) maths(220) fun(375) 
Alp2  remplace par  TimeReading: reading(0) writing(0) maths(95) fun(5) 
total: reading(225) writing(160) maths(315) fun(300) 
Cow5  remplace par  HoledWords: reading(65) writing(25) maths(0) fun(10) 
total: reading(220) writing(185) maths(315) fun(280) 
Num0  remplace par  DotToDotMath: reading(0) writing(0) maths(70) fun(30) 
total: reading(205) writing(185) maths(310) fun(300) 

Set :
1*[Dot2] : DotToDotMath: reading(0) writing(0) maths(70) fun(30) 
1*[Dot3] : DotToDotWrite: reading(0) writing(70) maths(0) fun(30) 
1*[Puz6] : Puzzle: reading(5) writing(0) maths(0) fun(95) 
1*[Cow3] : CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
1*[Wri2] : WritingWords: reading(0) writing(90) maths(0) fun(10) 
1*[Cow5] : CowTrainReading: reading(70) writing(0) maths(0) fun(30) 
1*[Ord8] : Ordering: reading(0) writing(0) maths(75) fun(25) 
1*[Tim1] : TimeReading: reading(0) writing(0) maths(95) fun(5) 
1*[Tex1] : TextReading: reading(65) writing(0) maths(0) fun(35) 
1*[Hol0] : HoledWords: reading(65) writing(25) maths(0) fun(10) 
add->start
ModuleGE[dep6]->bestfork->start
ModuleGE[dep6]->bestfork>after find
Node[dep6]->bestfork->no match
Fork->bestFork->start
Fork->bestFork->right recursive call
ModuleGE[Hol0]->bestfork->start
ModuleGE[Hol0]->bestfork>after find
ModuleGE[Hol0]->bestfork->match
Node[Hol0]->bestfork->module erased
Node[Hol0]->bestfork->recursive call and exit
ModuleGE[Dot3]->bestfork->start
ModuleGE[Dot3]->bestfork>after find
ModuleGE[Dot3]->bestfork->match
Node[Dot3]->bestfork->module erased
Node[Dot3]->bestfork->recursive call and exit
ModuleGE[Puz6]->bestfork->start
ModuleGE[Puz6]->bestfork>after find
ModuleGE[Puz6]->bestfork->match
Node[Puz6]->bestfork->module erased
Node[Puz6]->bestfork->recursive call and exit
ModuleGE[Ord8]->bestfork->start
ModuleGE[Ord8]->bestfork>after find
ModuleGE[Ord8]->bestfork->match
Node[Ord8]->bestfork->module erased
Node[Ord8]->bestfork->recursive call and exit
Fork->bestFork->start
Fork->bestFork->right recursive call
ModuleGE[Cow3]->bestfork->start
ModuleGE[Cow3]->bestfork>after find
ModuleGE[Cow3]->bestfork->match
Node[Cow3]->bestfork->module erased
Node[Cow3]->bestfork->recursive call and exit
ModuleGE[Wri2]->bestfork->start
ModuleGE[Wri2]->bestfork>after find
ModuleGE[Wri2]->bestfork->match
Node[Wri2]->bestfork->module erased
Node[Wri2]->bestfork->recursive call and exit
ModuleGE[Tim1]->bestfork->start
ModuleGE[Tim1]->bestfork>after find
ModuleGE[Tim1]->bestfork->match
Node[Tim1]->bestfork->module erased
Node[Tim1]->bestfork->recursive call and exit
ModuleGE[Tex7]->bestfork->start
ModuleGE[Tex7]->bestfork>after find
Node[Tex7]->bestfork->no match
Node[Tex7]->bestfork->new fork place
ModuleGE[Alp2]->bestfork->start
ModuleGE[Alp2]->bestfork>after find
Node[Alp2]->bestfork->no match
ModuleGE[Num0]->bestfork->start
ModuleGE[Num0]->bestfork>after find
Node[Num0]->bestfork->no match
Junction->bestFork
Fork->bestFork->left recursive call
ModuleGE[Dra8]->bestfork->start
ModuleGE[Dra8]->bestfork>after find
Node[Dra8]->bestfork->no match
Node[Dra8]->bestfork->new fork place
ModuleGE[Ord8]->bestfork->start
ModuleGE[Ord8]->bestfork>after find
Node[Ord8]->bestfork->no match
Junction->bestFork
Fork->bestFork->back from recursive calls
Fork->bestFork->left<right, delete and exit
Fork->bestFork->left recursive call
ModuleGE[Wri2]->bestfork->start
ModuleGE[Wri2]->bestfork>after find
ModuleGE[Wri2]->bestfork->match
Node[Wri2]->bestfork->module erased
Node[Wri2]->bestfork->recursive call and exit
ModuleGE[Tim1]->bestfork->start
ModuleGE[Tim1]->bestfork>after find
ModuleGE[Tim1]->bestfork->match
Node[Tim1]->bestfork->module erased
Node[Tim1]->bestfork->recursive call and exit
ModuleGE[Con5]->bestfork->start
ModuleGE[Con5]->bestfork>after find
Node[Con5]->bestfork->no match
Node[Con5]->bestfork->new fork place
Fork->bestFork->start
Fork->bestFork->fork place already found, exit
Fork->bestFork->back from recursive calls
Fork->bestFork->left<right, delete and exit
add->after bestFork
1*Dot2
1*Cow5
1*Tex1
-Tex7--Alp2--Num0->
Node[Tex7]->bestJunction->start
Node[Tex7]->bestJunction->forward
Node[Tex7]->bestJunction->module not found
Node[Alp2]->bestJunction->start
Node[Alp2]->bestJunction->forward
Node[Alp2]->bestJunction->module not found
Node[Num0]->bestJunction->start
Node[Num0]->bestJunction->forward
Node[Num0]->bestJunction->module not found
Junction->bestJunction
Junction->bestJunction->moving forward
Junction->bestJunction->contains() call
Junction->bestJunction->contains() returned true (good result)
Junction->bestJunction->new junction place
Junction->bestJunction->side != calling side => back recursive call
Junction->bestJunction->left recursive call
Node[Hol0]->bestJunction->start
Node[Hol0]->bestJunction->backward
Node[Hol0]->bestJunction->module not found, recursive call
Node[Wri4]->bestJunction->start
Node[Wri4]->bestJunction->backward
Node[Wri4]->bestJunction->module not found, recursive call
Node[Tex1]->bestJunction->start
Node[Tex1]->bestJunction->backward
Node[Tex1]->bestJunction->module found, removing module
Node[Tex1]->moving node
Node[Tex1]->bestJunction->recursive call
Node[Dot2]->bestJunction->start
Node[Dot2]->bestJunction->backward
Node[Dot2]->bestJunction->module found, removing module
Node[Dot2]->moving node
Node[Dot2]->bestJunction->recursive call
Junction->bestJunction
Junction->bestJunction->moving backward
distance negative or junction place far away, exit
Node[Dot2]->bestJunction->exit
Node[Tex1]->bestJunction->exit
Node[Wri4]->bestJunction->exit
Node[Hol0]->bestJunction->exit
Junction->bestJunction->back from back recursive call
Junction->bestJunction->new junction chosen
add->after BestJunction
-Dot2--Tex1->>
add->path
add->Modules left:
1*Cow5
add->forking left
add->forked first Node: Cow5
add->pathed
add->junction right
add->juncted
-dep6-<-Wri2--Tim1--Con5-<-Dra8--Hol0--Alp2--Wri4->-Tex7--Hid3--Num0->-arr7-
                         <-Cow3--Hol9-<-Wri2--Hid3->
                                      <-Con5->-Wri4--Hol0->-Dot2--Tex1->>
      <-Hol0--Dot3--Puz6--Ord8-<-Dra8--Ord8->
                               <-Cow3--Wri2--Tim1-<-Cow5->
                                                  <-Tex7--Alp2--Num0->

Base :
1*[Dra8] : DrawNode: reading(0) writing(0) maths(80) fun(20) 
1*[Dot3] : DotToDotWrite: reading(0) writing(70) maths(0) fun(30) 
1*[Con5] : ConnectsTheDots: reading(0) writing(0) maths(30) fun(70) 
1*[Cow3] : CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
2*[Hol9] : HoledText: reading(80) writing(10) maths(0) fun(10) 
1*[Cow5] : CowTrainReading: reading(70) writing(0) maths(0) fun(30) 
1*[Alp2] : AlphabetSong: reading(20) writing(0) maths(0) fun(80) 
1*[Num0] : NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
1*[Wri4] : WritingLetters: reading(0) writing(75) maths(0) fun(25) 
total: reading(265) writing(165) maths(255) fun(315) 
Hol9  remplace par  NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
total: reading(200) writing(155) maths(330) fun(315) 
Con5  remplace par  DotToDotWrite: reading(0) writing(70) maths(0) fun(30) 
total: reading(200) writing(225) maths(300) fun(275) 
Hol9  remplace par  TextReading: reading(65) writing(0) maths(0) fun(35) 
total: reading(185) writing(215) maths(300) fun(300) 

Set :
1*[Dra8] : DrawNode: reading(0) writing(0) maths(80) fun(20) 
2*[Dot3] : DotToDotWrite: reading(0) writing(70) maths(0) fun(30) 
1*[Cow3] : CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
1*[Cow5] : CowTrainReading: reading(70) writing(0) maths(0) fun(30) 
1*[Tex1] : TextReading: reading(65) writing(0) maths(0) fun(35) 
1*[Alp2] : AlphabetSong: reading(20) writing(0) maths(0) fun(80) 
2*[Num0] : NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
1*[Wri4] : WritingLetters: reading(0) writing(75) maths(0) fun(25) 
add->start
ModuleGE[dep6]->bestfork->start
ModuleGE[dep6]->bestfork>after find
Node[dep6]->bestfork->no match
Fork->bestFork->start
Fork->bestFork->right recursive call
ModuleGE[Hol0]->bestfork->start
ModuleGE[Hol0]->bestfork>after find
Node[Hol0]->bestfork->no match
Node[Hol0]->bestfork->new fork place
ModuleGE[Dot3]->bestfork->start
ModuleGE[Dot3]->bestfork>after find
ModuleGE[Dot3]->bestfork->match
Node[Dot3]->bestfork->module erased
Node[Dot3]->bestfork->moving
Node[Dot3]->bestfork->recursive call and exit
ModuleGE[Puz6]->bestfork->start
ModuleGE[Puz6]->bestfork>after find
Node[Puz6]->bestfork->no match
ModuleGE[Ord8]->bestfork->start
ModuleGE[Ord8]->bestfork>after find
Node[Ord8]->bestfork->no match
Fork->bestFork->start
Fork->bestFork->fork place already found, exit
Fork->bestFork->left recursive call
ModuleGE[Wri2]->bestfork->start
ModuleGE[Wri2]->bestfork>after find
Node[Wri2]->bestfork->no match
Node[Wri2]->bestfork->new fork place
ModuleGE[Tim1]->bestfork->start
ModuleGE[Tim1]->bestfork>after find
Node[Tim1]->bestfork->no match
ModuleGE[Con5]->bestfork->start
ModuleGE[Con5]->bestfork>after find
Node[Con5]->bestfork->no match
Fork->bestFork->start
Fork->bestFork->fork place already found, exit
Fork->bestFork->back from recursive calls
Fork->bestFork->left<right, delete and exit
add->after bestFork
1*Dra8
1*Dot3
1*Cow3
1*Cow5
1*Tex1
1*Alp2
2*Num0
1*Wri4
-Hol0--Puz6--Ord8-<-Dra8--Ord8->
                  <-Cow3--Wri2--Tim1-<-Cow5->
                                     <-Tex7--Alp2--Num0->
Node[Hol0]->bestJunction->start
Node[Hol0]->bestJunction->forward
Node[Hol0]->bestJunction->module not found
Node[Puz6]->bestJunction->start
Node[Puz6]->bestJunction->forward
Node[Puz6]->bestJunction->module not found
Node[Ord8]->bestJunction->start
Node[Ord8]->bestJunction->forward
Node[Ord8]->bestJunction->module not found
Fork->bestJunction->start
Fork->bestJunction->moving forward
Fork->bestJunction->side = both
Fork->bestJunction->left recursive call
Node[Dra8]->bestJunction->start
Node[Dra8]->bestJunction->forward
Node[Dra8]->bestJunction->module found or null
Node[Dra8]->bestJunction->removing module
Node[Dra8]->bestJunction->new junction place
Node[Dra8]->bestJunction->recursive call
Node[Ord8]->bestJunction->start
Node[Ord8]->bestJunction->forward
Node[Ord8]->bestJunction->module not found
Node[0x996628]->bestJunction->moving node
Node[0x996628]->bestJunction->recursive call and exit
Junction->bestJunction
Junction->bestJunction->moving forward
Junction->bestJunction->contains() call
Junction->bestJunction->contains() returned false=> junction place is bad
Junction->bestJunction->not compatible side
Junction->bestJunction->exit
Node[Dra8]->bestJunction->junctionPlace was moved to another area
Node[Dra8]->bestJunction->replacing module in the list
Node[Dra8]->bestJunction->exit
Fork->bestJunction->right recursive call
Node[Cow3]->bestJunction->start
Node[Cow3]->bestJunction->forward
Node[Cow3]->bestJunction->module found or null
Node[Cow3]->bestJunction->removing module
Node[Cow3]->bestJunction->new junction place
Node[Cow3]->bestJunction->recursive call
Node[Wri2]->bestJunction->start
Node[Wri2]->bestJunction->forward
Node[Wri2]->bestJunction->module not found
Node[0x996508]->bestJunction->moving node
Node[0x996508]->bestJunction->recursive call and exit
Node[Tim1]->bestJunction->start
Node[Tim1]->bestJunction->forward
Node[Tim1]->bestJunction->module not found
Node[0x996668]->bestJunction->moving node
Node[0x996668]->bestJunction->recursive call and exit
Fork->bestJunction->start
Fork->bestJunction->moving forward
Fork->bestJunction->junctionPlace already found
Fork->bestJunction->right contains() call
Fork->bestJunction->right bestFork fails
Fork->bestJunction->this junction place is bad => junction place not found
Fork->bestJunction->side = right => right recursive call
Node[Tex7]->bestJunction->start
Node[Tex7]->bestJunction->forward
Node[Tex7]->bestJunction->module not found
Node[Alp2]->bestJunction->start
Node[Alp2]->bestJunction->forward
Node[Alp2]->bestJunction->module found or null
Node[Alp2]->bestJunction->removing module
Node[Alp2]->bestJunction->new junction place
Node[Alp2]->bestJunction->recursive call
Node[Num0]->bestJunction->start
Node[Num0]->bestJunction->forward
Node[Num0]->bestJunction->module found or null
Node[Num0]->bestJunction->removing module
Node[Num0]->bestJunction->recursive call
Junction->bestJunction
Junction->bestJunction->moving forward
Junction->bestJunction->contains() call
Junction->bestJunction->contains() returned true (good result)
Junction->bestJunction->exit
Node[Num0]->bestJunction->junctionPlace still on this path
Node[Num0]->bestJunction->exit
Node[Alp2]->bestJunction->junctionPlace still on this path
Node[Alp2]->bestJunction->exit
Fork->bestJunction->back from right recursive call
Fork->bestJunction->exit
Node[Cow3]->bestJunction->junctionPlace was moved to another area
Node[Cow3]->bestJunction->replacing module in the list
Node[Cow3]->bestJunction->exit
Fork->bestJunction->back from recursive calls
Fork->bestJunction->choosing right
Fork->bestJunction->exit
add->after BestJunction
-Alp2--Num0->
add->path
add->Modules left:
1*Dra8
1*Dot3
1*Cow3
1*Cow5
1*Tex1
1*Num0
1*Wri4
add->forking right
add->forked first Node: Dra8
add->node Dot3
add->node Cow3
add->node Cow5
add->node Tex1
add->node Num0
add->node Wri4
add->pathed
add->junction right
add->juncted
-dep6-<-Wri2--Tim1--Con5-<-Dra8--Hol0--Alp2--Wri4->-Tex7--Hid3--Num0->-arr7-
                         <-Cow3--Hol9-<-Wri2--Hid3->
                                      <-Con5->-Wri4--Hol0->-Dot2--Tex1->>
      <-Dot3-<-Hol0--Puz6--Ord8-<-Ord8--Dra8->
                                <-Wri2--Tim1--Cow3-<-Cow5->
                                                   <-Tex7->-Alp2--Num0->
             <-Dra8--Dot3--Cow3--Cow5--Tex1--Num0--Wri4->

Base :
1*[Dra8] : DrawNode: reading(0) writing(0) maths(80) fun(20) 
2*[Dot2] : DotToDotMath: reading(0) writing(0) maths(70) fun(30) 
1*[Con5] : ConnectsTheDots: reading(0) writing(0) maths(30) fun(70) 
1*[Wri2] : WritingWords: reading(0) writing(90) maths(0) fun(10) 
1*[Ord8] : Ordering: reading(0) writing(0) maths(75) fun(25) 
1*[Tex7] : TextUnderstanding: reading(95) writing(0) maths(0) fun(5) 
1*[Hol0] : HoledWords: reading(65) writing(25) maths(0) fun(10) 
1*[Alp2] : AlphabetSong: reading(20) writing(0) maths(0) fun(80) 
1*[Wri4] : WritingLetters: reading(0) writing(75) maths(0) fun(25) 
total: reading(180) writing(190) maths(325) fun(305) 
Dot2  remplace par  NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
total: reading(195) writing(190) maths(330) fun(285) 
Dra8  remplace par  CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
total: reading(195) writing(190) maths(320) fun(295) 
Con5  remplace par  HiddenObjects: reading(5) writing(0) maths(20) fun(75) 
total: reading(200) writing(190) maths(310) fun(300) 

Set :
1*[Dot2] : DotToDotMath: reading(0) writing(0) maths(70) fun(30) 
1*[Cow3] : CowTrainMaths: reading(0) writing(0) maths(70) fun(30) 
1*[Wri2] : WritingWords: reading(0) writing(90) maths(0) fun(10) 
1*[Ord8] : Ordering: reading(0) writing(0) maths(75) fun(25) 
1*[Tex7] : TextUnderstanding: reading(95) writing(0) maths(0) fun(5) 
1*[Hid3] : HiddenObjects: reading(5) writing(0) maths(20) fun(75) 
1*[Hol0] : HoledWords: reading(65) writing(25) maths(0) fun(10) 
1*[Alp2] : AlphabetSong: reading(20) writing(0) maths(0) fun(80) 
1*[Num0] : NumberInWords/Figure: reading(15) writing(0) maths(75) fun(10) 
1*[Wri4] : WritingLetters: reading(0) writing(75) maths(0) fun(25) 
add->start
ModuleGE[dep6]->bestfork->start
ModuleGE[dep6]->bestfork>after find
Node[dep6]->bestfork->no match
Fork->bestFork->start
Fork->bestFork->right recursive call
ModuleGE[Dot3]->bestfork->start
ModuleGE[Dot3]->bestfork>after find
Node[Dot3]->bestfork->no match
Node[Dot3]->bestfork->new fork place
Fork->bestFork->start
Fork->bestFork->fork place already found, exit
Fork->bestFork->left recursive call
ModuleGE[Wri2]->bestfork->start
ModuleGE[Wri2]->bestfork>after find
ModuleGE[Wri2]->bestfork->match
Node[Wri2]->bestfork->module erased
Node[Wri2]->bestfork->recursive call and exit
ModuleGE[Tim1]->bestfork->start
ModuleGE[Tim1]->bestfork>after find
Node[Tim1]->bestfork->no match
Node[Tim1]->bestfork->new fork place
ModuleGE[Con5]->bestfork->start
ModuleGE[Con5]->bestfork>after find
Node[Con5]->bestfork->no match
Fork->bestFork->start
Fork->bestFork->fork place already found, exit
Fork->bestFork->back from recursive calls
Fork->bestFork->left>=right, delete and exit
add->after bestFork
1*Dot2
1*Cow3
1*Ord8
1*Tex7
1*Hid3
1*Hol0
1*Alp2
1*Num0
1*Wri4
-Tim1--Con5-<-Dra8--Hol0--Alp2--Wri4->-Tex7--Hid3--Num0->-arr7-
            <-Cow3--Hol9-<-Wri2--Hid3->
                         <-Con5->-Wri4--Hol0->-Dot2--Tex1->>
Node[Tim1]->bestJunction->start
Node[Tim1]->bestJunction->forward
Node[Tim1]->bestJunction->module not found
Node[Con5]->bestJunction->start
Node[Con5]->bestJunction->forward
Node[Con5]->bestJunction->module not found
Fork->bestJunction->start
Fork->bestJunction->moving forward
Fork->bestJunction->side = both
Fork->bestJunction->left recursive call
Node[Dra8]->bestJunction->start
Node[Dra8]->bestJunction->forward
Node[Dra8]->bestJunction->module not found
Node[Hol0]->bestJunction->start
Node[Hol0]->bestJunction->forward
Node[Hol0]->bestJunction->module found or null
Node[Hol0]->bestJunction->removing module
Node[Hol0]->bestJunction->new junction place
Node[Hol0]->bestJunction->recursive call
Node[Alp2]->bestJunction->start
Node[Alp2]->bestJunction->forward
Node[Alp2]->bestJunction->module found or null
Node[Alp2]->bestJunction->removing module
Node[Alp2]->bestJunction->recursive call
Node[Wri4]->bestJunction->start
Node[Wri4]->bestJunction->forward
Node[Wri4]->bestJunction->module found or null
Node[Wri4]->bestJunction->removing module
Node[Wri4]->bestJunction->recursive call
Junction->bestJunction
Junction->bestJunction->moving forward
Junction->bestJunction->contains() call
Junction->bestJunction->contains() returned true (good result)
Junction->bestJunction->exit
Node[Wri4]->bestJunction->junctionPlace still on this path
Node[Wri4]->bestJunction->exit
Node[Alp2]->bestJunction->junctionPlace still on this path
Node[Alp2]->bestJunction->exit
Node[Hol0]->bestJunction->junctionPlace still on this path
Node[Hol0]->bestJunction->exit
Fork->bestJunction->right recursive call
Node[Cow3]->bestJunction->start
Node[Cow3]->bestJunction->forward
Node[Cow3]->bestJunction->module found or null
Node[Cow3]->bestJunction->removing module
Node[Cow3]->bestJunction->new junction place
Node[Cow3]->bestJunction->recursive call
Node[Hol9]->bestJunction->start
Node[Hol9]->bestJunction->forward
Node[Hol9]->bestJunction->module not found
Node[0x996548]->bestJunction->moving node
Node[0x996548]->bestJunction->recursive call and exit
Fork->bestJunction->start
Fork->bestJunction->moving forward
Fork->bestJunction->junctionPlace already found
Fork->bestJunction->right contains() call
Fork->bestJunction->right bestFork fails
Fork->bestJunction->this junction place is bad => junction place not found
Fork->bestJunction->side = right => right recursive call
Node[Con5]->bestJunction->start
Node[Con5]->bestJunction->forward
Node[Con5]->bestJunction->module not found
Junction->bestJunction
Junction->bestJunction->moving forward
Junction->bestJunction->contains() call
Junction->bestJunction->contains() returned false=> junction place is bad
Junction->bestJunction->not compatible side
Junction->bestJunction->exit
Fork->bestJunction->back from right recursive call
Fork->bestJunction->exit
Node[Cow3]->bestJunction->junctionPlace was moved to another area
Node[Cow3]->bestJunction->replacing module in the list
Node[Cow3]->bestJunction->exit
Fork->bestJunction->back from recursive calls
Fork->bestJunction->choosing left
Fork->bestJunction->exit
add->after BestJunction
-Hol0--Alp2--Wri4->-Tex7--Hid3--Num0->-arr7-
add->path
add->Modules left:
1*Dot2
1*Cow3
1*Ord8
add->forking left
add->forked first Node: Dot2
add->node Cow3
add->node Ord8
add->pathed
add->junction left
add->juncted
-dep6-<-Wri2-<-Dot2--Cow3--Ord8->-Hol0--Alp2--Wri4->-Tex7--Hid3--Num0->-arr7-
             <-Tim1--Con5-<-Dra8->
                          <-Hol9--Cow3-<-Wri2--Hid3->
                                       <-Con5->-Wri4--Hol0->-Dot2--Tex1->>
      <-Dot3-<-Hol0--Puz6--Ord8-<-Ord8--Dra8->
                                <-Wri2--Tim1--Cow3-<-Cow5->
                                                   <-Tex7->-Alp2--Num0->
             <-Dra8--Dot3--Cow3--Cow5--Tex1--Num0--Wri4->


Transforming the pre-graph in usable graph.
Getting the GE map and checking for validity.
Node[dep6]->distance and validity check
Node[dep6]->added to the distanceMap (d=0)
Node[dep6]->recursive call on next GE
Fork->distance and validity check
Fork->fork not found in the map
Fork->fork added to the map
Fork->fork added to the map (d=0)
Fork->recursive call on left GE
Node[Wri2]->distance and validity check
Node[Wri2]->added to the distanceMap (d=1)
Node[Wri2]->recursive call on next GE
Fork->distance and validity check
Fork->fork not found in the map
Fork->fork added to the map
Fork->fork added to the map (d=1)
Fork->recursive call on left GE
Node[Dot2]->distance and validity check
Node[Dot2]->added to the distanceMap (d=2)
Node[Dot2]->recursive call on next GE
Node[Cow3]->distance and validity check
Node[Cow3]->added to the distanceMap (d=3)
Node[Cow3]->recursive call on next GE
Node[Ord8]->distance and validity check
Node[Ord8]->added to the distanceMap (d=4)
Node[Ord8]->recursive call on next GE
Junction->distance and validity check
Junction->added to the map (d=4)
Junction->right recursive call
Node[Dra8]->distance and validity check
Node[Dra8]->added to the distanceMap (d=4)
Node[Dra8]->recursive call on previous GE
Fork->distance and validity check
Fork->fork not found in the map
Fork->fork added to the map
Fork->recursive call on previous GE
Node[Con5]->distance and validity check
Node[Con5]->added to the distanceMap (d=3)
Node[Con5]->recursive call on previous GE
Node[Tim1]->distance and validity check
Node[Tim1]->added to the distanceMap (d=2)
Node[Tim1]->recursive call on previous GE
Fork->distance and validity check
Fork->fork already encountered once
Node[Tim1]->back from recursive call
Node[Con5]->back from recursive call
Fork->back from recursive call
Node[Dra8]->back from recursive call
Junction->back from recursive call
Junction->next recursive call
Node[Hol0]->distance and validity check
Node[Hol0]->added to the distanceMap (d=5)
Node[Hol0]->recursive call on next GE
Node[Alp2]->distance and validity check
Node[Alp2]->added to the distanceMap (d=6)
Node[Alp2]->recursive call on next GE
Node[Wri4]->distance and validity check
Node[Wri4]->added to the distanceMap (d=7)
Node[Wri4]->recursive call on next GE
Junction->distance and validity check
Junction->added to the map (d=7)
Junction->right recursive call
Node[Hid3]->distance and validity check
Node[Hid3]->added to the distanceMap (d=7)
Node[Hid3]->recursive call on previous GE
Node[Wri2]->distance and validity check
Node[Wri2]->added to the distanceMap (d=6)
Node[Wri2]->recursive call on previous GE
Fork->distance and validity check
Fork->fork not found in the map
Fork->fork added to the map
Fork->recursive call on previous GE
Node[Cow3]->distance and validity check
Node[Cow3]->added to the distanceMap (d=5)
Node[Cow3]->recursive call on previous GE
Node[Hol9]->distance and validity check
Node[Hol9]->added to the distanceMap (d=4)
Node[Hol9]->recursive call on previous GE
Fork->distance and validity check
Fork->fork already encountered once
Node[Hol9]->back from recursive call
Node[Cow3]->back from recursive call
Fork->back from recursive call
Node[Wri2]->back from recursive call
Node[Hid3]->back from recursive call
Junction->back from recursive call
Junction->next recursive call
Node[Tex7]->distance and validity check
Node[Tex7]->added to the distanceMap (d=8)
Node[Tex7]->recursive call on next GE
Node[Hid3]->distance and validity check
Node[Hid3]->added to the distanceMap (d=9)
Node[Hid3]->recursive call on next GE
Node[Num0]->distance and validity check
Node[Num0]->added to the distanceMap (d=10)
Node[Num0]->recursive call on next GE
Junction->distance and validity check
Junction->added to the map (d=10)
Junction->right recursive call
Junction->distance and validity check
Junction->added to the map (d=10)
Junction->left recursive call
Node[Tex1]->distance and validity check
Node[Tex1]->added to the distanceMap (d=10)
Node[Tex1]->recursive call on previous GE
Node[Dot2]->distance and validity check
Node[Dot2]->added to the distanceMap (d=9)
Node[Dot2]->recursive call on previous GE
Junction->distance and validity check
Junction->added to the map (d=8)
Junction->left recursive call
Node[Hol0]->distance and validity check
Node[Hol0]->added to the distanceMap (d=8)
Node[Hol0]->recursive call on previous GE
Node[Wri4]->distance and validity check
Node[Wri4]->added to the distanceMap (d=7)
Node[Wri4]->recursive call on previous GE
Junction->distance and validity check
Junction->added to the map (d=6)
Junction->left recursive call
Node[Con5]->distance and validity check
Node[Con5]->added to the distanceMap (d=6)
Node[Con5]->recursive call on previous GE
Fork->distance and validity check
Fork->fork already encountered once
Node[Con5]->back from recursive call
Junction->back from recursive call
Junction->right recursive call
Node[Dra8]->distance and validity check
Node[Dra8]->added to the distanceMap (d=6)
Node[Dra8]->recursive call on previous GE
Node[Ord8]->distance and validity check
Node[Ord8]->added to the distanceMap (d=5)
Node[Ord8]->recursive call on previous GE
Fork->distance and validity check
Fork->fork not found in the map
Fork->fork added to the map
Fork->recursive call on previous GE
Node[Ord8]->distance and validity check
Node[Ord8]->added to the distanceMap (d=4)
Node[Ord8]->recursive call on previous GE
Node[Puz6]->distance and validity check
Node[Puz6]->added to the distanceMap (d=3)
Node[Puz6]->recursive call on previous GE
Node[Hol0]->distance and validity check
Node[Hol0]->added to the distanceMap (d=2)
Node[Hol0]->recursive call on previous GE
Fork->distance and validity check
Fork->fork not found in the map
Fork->fork added to the map
Fork->recursive call on previous GE
Node[Dot3]->distance and validity check
Node[Dot3]->added to the distanceMap (d=1)
Node[Dot3]->recursive call on previous GE
Fork->distance and validity check
Fork->fork already encountered once
Node[Dot3]->back from recursive call
Fork->back from recursive call
Node[Hol0]->back from recursive call
Node[Puz6]->back from recursive call
Node[Ord8]->back from recursive call
Fork->back from recursive call
Node[Ord8]->back from recursive call
Node[Dra8]->back from recursive call
Junction->back from recursive call
Node[Wri4]->back from recursive call
Node[Hol0]->back from recursive call
Junction->back from recursive call
Junction->right recursive call
Node[Cow5]->distance and validity check
Node[Cow5]->added to the distanceMap (d=8)
Node[Cow5]->recursive call on previous GE
Fork->distance and validity check
Fork->fork not found in the map
Fork->fork added to the map
Fork->recursive call on previous GE
Node[Cow3]->distance and validity check
Node[Cow3]->added to the distanceMap (d=7)
Node[Cow3]->recursive call on previous GE
Node[Tim1]->distance and validity check
Node[Tim1]->added to the distanceMap (d=6)
Node[Tim1]->recursive call on previous GE
Node[Wri2]->distance and validity check
Node[Wri2]->added to the distanceMap (d=5)
Node[Wri2]->recursive call on previous GE
Fork->distance and validity check
Fork->fork already encountered once
Node[Wri2]->back from recursive call
Node[Tim1]->back from recursive call
Node[Cow3]->back from recursive call
Fork->back from recursive call
Node[Cow5]->back from recursive call
Junction->back from recursive call
Node[Dot2]->back from recursive call
Node[Tex1]->back from recursive call
Junction->back from recursive call
Junction->right recursive call
Node[Num0]->distance and validity check
Node[Num0]->added to the distanceMap (d=10)
Node[Num0]->recursive call on previous GE
Node[Alp2]->distance and validity check
Node[Alp2]->added to the distanceMap (d=9)
Node[Alp2]->recursive call on previous GE
Junction->distance and validity check
Junction->added to the map (d=8)
Junction->left recursive call
Node[Tex7]->distance and validity check
Node[Tex7]->added to the distanceMap (d=8)
Node[Tex7]->recursive call on previous GE
Fork->distance and validity check
Fork->fork already encountered once
Node[Tex7]->back from recursive call
Junction->back from recursive call
Junction->right recursive call
Node[Wri4]->distance and validity check
Node[Wri4]->added to the distanceMap (d=8)
Node[Wri4]->recursive call on previous GE
Node[Num0]->distance and validity check
Node[Num0]->added to the distanceMap (d=7)
Node[Num0]->recursive call on previous GE
Node[Tex1]->distance and validity check
Node[Tex1]->added to the distanceMap (d=6)
Node[Tex1]->recursive call on previous GE
Node[Cow5]->distance and validity check
Node[Cow5]->added to the distanceMap (d=5)
Node[Cow5]->recursive call on previous GE
Node[Cow3]->distance and validity check
Node[Cow3]->added to the distanceMap (d=4)
Node[Cow3]->recursive call on previous GE
Node[Dot3]->distance and validity check
Node[Dot3]->added to the distanceMap (d=3)
Node[Dot3]->recursive call on previous GE
Node[Dra8]->distance and validity check
Node[Dra8]->added to the distanceMap (d=2)
Node[Dra8]->recursive call on previous GE
Fork->distance and validity check
Fork->fork already encountered once
Node[Dra8]->back from recursive call
Node[Dot3]->back from recursive call
Node[Cow3]->back from recursive call
Node[Cow5]->back from recursive call
Node[Tex1]->back from recursive call
Node[Num0]->back from recursive call
Node[Wri4]->back from recursive call
Junction->back from recursive call
Node[Alp2]->back from recursive call
Node[Num0]->back from recursive call
Junction->back from recursive call
Junction->back from recursive call
Junction->next recursive call
Node[arr7]->distance and validity check
Node[arr7]->added to the distanceMap (d=11)
Junction->back from recursive call
Node[Num0]->back from recursive call
Node[Hid3]->back from recursive call
Node[Tex7]->back from recursive call
Junction->back from recursive call
Node[Wri4]->back from recursive call
Node[Alp2]->back from recursive call
Node[Hol0]->back from recursive call
Junction->back from recursive call
Node[Ord8]->back from recursive call
Node[Cow3]->back from recursive call
Node[Dot2]->back from recursive call
Fork->back from recursive call
Node[Wri2]->back from recursive call
Fork->back from recursive call
Node[dep6]->back from recursive call
The pre-graph is valid.

Insertion of node Con5(3,7)
Insertion of node Cow3(5,14)
Insertion of node Wri2(6,13)
Insertion of node Tex7(8,16)
Insertion of node Hid3(7,12)
Insertion of node arr7(11,44)
Insertion of node Num0(10,18)
Insertion of node Wri2(1,2)
Insertion of node Hol9(4,15)
Insertion of node dep6(0,1)
Insertion of node Tim1(2,8)
Insertion of node Hid3(9,17)
Insertion of node Tim1(6,32)
Insertion of node Wri2(5,33)
Insertion of node Num0(10,34)
Insertion of node Tex7(8,36)
Insertion of node Alp2(9,35)
Insertion of node Cow3(7,31)
Insertion of node Con5(6,23)
Insertion of node Ord8(4,26)
Insertion of node Tex1(10,19)
Insertion of node Dot3(1,29)
Insertion of node Puz6(3,27)
Insertion of node Hol0(8,21)
Insertion of node Wri4(7,22)
Insertion of node Dra8(6,24)
Insertion of node Hol0(2,28)
Insertion of node Dot2(9,20)
Insertion of node Ord8(5,25)
Insertion of node Cow3(3,4)
Insertion of node Alp2(6,10)
Insertion of node Dra8(4,6)
Insertion of node Hol0(5,9)
Insertion of node Wri4(7,11)
Insertion of node Cow5(8,30)
Insertion of node Dot2(2,3)
Insertion of node Ord8(4,5)
Insertion of node Num0(7,38)
Insertion of node Cow5(5,40)
Insertion of node Wri4(8,37)
Insertion of node Dot3(3,42)
Insertion of node Cow3(4,41)
Insertion of node Tex1(6,39)
Insertion of node Dra8(2,43)


Added the list of node to the graph.

Linking parent nodes to children nodes:
Con5-> Dra8 Hol9
Cow3-> Wri2 Con5
Wri2-> Hid3
Tex7-> Hid3
Hid3-> Tex7
arr7->
Num0-> arr7
Wri2-> Dot2 Tim1
Hol9-> Cow3
dep6-> Wri2 Dot3
Tim1-> Con5
Hid3-> Num0
Tim1-> Cow3
Wri2-> Tim1
Num0-> arr7
Tex7-> Alp2
Alp2-> Num0
Cow3-> Cow5 Tex7
Con5-> Wri4
Ord8-> Ord8 Wri2
Tex1-> arr7
Dot3-> Hol0 Dra8
Puz6-> Ord8
Hol0-> Dot2
Wri4-> Hol0
Dra8-> Wri4
Hol0-> Puz6
Dot2-> Tex1
Ord8-> Dra8
Cow3-> Ord8
Alp2-> Wri4
Dra8-> Hol0
Hol0-> Alp2
Wri4-> Tex7
Cow5-> Dot2
Dot2-> Cow3
Ord8-> Hol0
Num0-> Wri4
Cow5-> Tex1
Wri4-> Alp2
Dot3-> Cow3
Cow3-> Cow5
Tex1-> Num0
Dra8-> Dot3

Usable graph completely generated.

Computing the graph data.
Graph matches with the asked learnings values.

Graph of dimensions (10,6):
Number of paths: 8
Asked learnings: reading(200) writing(200) maths(300) fun(300) 
Authorized difference: reading(50) writing(50) maths(50) fun(50) 
Min: reading(185) writing(185) maths(295) fun(295) 
Max: reading(210) writing(215) maths(315) fun(310) 
Max difference: 30
Average difference: 22.5
dep6(2)     
Wri2(2)     Dot3(2)     
Dot2(1)     Tim1(1)     Hol0(1)     Dra8(1)     
Cow3(1)     Con5(2)     Puz6(1)     Dot3(1)     
Ord8(1)     Dra8(1)     Hol9(1)     Ord8(2)     Cow3(1)     
Hol0(1)     Cow3(2)     Ord8(1)     Wri2(1)     Cow5(1)     
Alp2(1)     Wri2(1)     Con5(1)     Dra8(1)     Tim1(1)     Tex1(1)     
Wri4(1)     Hid3(1)     Wri4(1)     Cow3(2)     Num0(1)     
Tex7(1)     Hol0(1)     Cow5(1)     Tex7(1)     Wri4(1)     
Hid3(1)     Dot2(1)     Alp2(1)     
Num0(1)     Tex1(1)     Num0(1)     
arr7(0)     
